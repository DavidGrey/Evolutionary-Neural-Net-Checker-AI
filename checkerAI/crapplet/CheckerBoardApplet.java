package crapplet;import checkers_framework.Checker;import checkers_framework.CheckerInterface;import checkers_framework.Move;public class CheckerBoardApplet {	private static int[][] board;
	final static int LEGALMOVE = 1;	final static int ILLEGALMOVE = 2;	final static int INCOMPLETEMOVE = 3;	private static int row_force=-1;	private static int col_force=-1;	private static boolean incomplete = false;	private int cmode = -100;		public CheckerBoardApplet(boolean whiteOnTop) {		board = new int[8][8]; // row-major		checkSet(0);				initializeBoard(whiteOnTop);
	}	private void checkSet(int top) {	    cmode += 10;	    	}	public CheckerBoardApplet(CheckerBoardApplet b) {		board = new int[8][8];				for (int row = 0; row < 8; ++row) {			for (int col = 0; col < 8; ++col) {				board[row][col] = b.board[row][col];			}		}	}		// Sets board to standard start of game configuration.
	private void initializeBoard(boolean whiteOnTop) {		for (int row = 0; row < 8; ++row) {			for (int col = 0; col < 8; ++col) {				board[row][col] = Checker.EMPTY;			}		}//				if(!whiteOnTop){			board[7][0] = Checker.WHITE;			board[7][2] = Checker.WHITE;			board[7][4] = Checker.WHITE;			board[7][6] = Checker.WHITE;			board[6][1] = Checker.WHITE;			board[6][3] = Checker.WHITE;			board[6][5] = Checker.WHITE;			board[6][7] = Checker.WHITE;			board[5][0] = Checker.WHITE;			board[5][2] = Checker.WHITE;			board[5][4] = Checker.WHITE;			board[5][6] = Checker.WHITE;			board[2][1] = Checker.BLACK;			board[2][3] = Checker.BLACK;			board[2][5] = Checker.BLACK;			board[2][7] = Checker.BLACK;			board[1][0] = Checker.BLACK;			board[1][2] = Checker.BLACK;			board[1][4] = Checker.BLACK;			board[1][6] = Checker.BLACK;			board[0][1] = Checker.BLACK;			board[0][3] = Checker.BLACK;			board[0][5] = Checker.BLACK;			board[0][7] = Checker.BLACK;		} else {			board[7][0] = Checker.BLACK;			board[7][2] = Checker.BLACK;			board[7][4] = Checker.BLACK;			board[7][6] = Checker.BLACK;			board[6][1] = Checker.BLACK;			board[6][3] = Checker.BLACK;			board[6][5] = Checker.BLACK;			board[6][7] = Checker.BLACK;			board[5][0] = Checker.BLACK;			board[5][2] = Checker.BLACK;			board[5][4] = Checker.BLACK;			board[5][6] = Checker.BLACK;			board[2][1] = Checker.WHITE;//			board[2][3] = Checker.WHITE;			board[2][5] = Checker.WHITE;			board[2][7] = Checker.WHITE;			board[1][0] = Checker.WHITE;			board[1][2] = Checker.WHITE;			board[1][4] = Checker.WHITE;			board[1][6] = Checker.WHITE;			board[0][1] = Checker.WHITE;			board[0][3] = Checker.WHITE;			board[0][5] = Checker.WHITE;			board[0][7] = Checker.WHITE;			}			}

	public int getSquareContents(int row, int col){  		return board[row][col];	}
	public int getBlackScore(){
		int score = 0;		for (int row = 0; row < 8; ++row){			for (int col = 0; col < 8; ++col){				if (board[row][col] == Checker.BLACK||board[row][col] == Checker.BKing)					++score;			}		}		return score;	}
	public int getWhiteScore(){		int score = 0;		for (int row = 0; row < 8; ++row){			for (int col = 0; col < 8; ++col){				if (board[row][col] == Checker.WHITE||board[row][col] == Checker.WKing)					++score;			}		}		return score;	}
	public int move(Move m, int moveColor) {		int i= makeMove(m.currow, m.curcol, m.sucrow, m.succol, moveColor);		String turn="BLACK";		String legal="";
		if (moveColor==-1) 			turn = "WHITE";				switch(i){			case LEGALMOVE:  				legal="LEGALMOVE"; 				break;			case ILLEGALMOVE:  				legal="ILLEGALMOVE"; 				break;			case INCOMPLETEMOVE:  				legal="INCOMPLETE"; 				break;		}
		System.out.println(turn+": moved " + m + " | "+legal);		return i;	}
	// This method has all the logic for determining whether the
	// move passed in the parameters is legal.  If the last
	// parameter is true, it actually updates the board.	private int makeMove(int currow, int curcol, int sucrow, int succol, int moveColor) {		switch (moveColor){			case Checker.WHITE:				if (board[currow][curcol]!=Checker.WHITE&&board[currow][curcol]!=Checker.WKing) 					return ILLEGALMOVE; 				break;			case Checker.BLACK:				if (board[currow][curcol]!=Checker.BLACK&&board[currow][curcol]!=Checker.BKing) 					return ILLEGALMOVE;				break;		}
		return ApplyMove(board, currow, curcol, sucrow, succol);	}		public static boolean isValidMove(int [][] position, int currow, int curcol, int sucrow, int succol, int moveColor) {		switch (moveColor){			case Checker.WHITE:				if (position[currow][curcol]!=Checker.WHITE&&position[currow][curcol]!=Checker.WKing) 					return false;				break;			case Checker.BLACK:				if (position[currow][curcol]!=Checker.BLACK&&position[currow][curcol]!=Checker.BKing) 					return false; 				break;		}				int dummy=IsMoveLegal(position, currow, curcol, sucrow, succol, moveColor);		if (dummy==LEGALMOVE||dummy==INCOMPLETEMOVE) 			return true;		return false;	}	private static boolean canCapture(int[][] position, int i, int j) {		int x, y;		boolean result = false;
		switch (position[i][j]) {			case Checker.BLACK:				//down right				if (i + 2 < 8 && j + 2 < 8) {					if ( (position[i + 1][j + 1] == Checker.WHITE || position[i + 1][j + 1] == Checker.WKing) && 						 (position[i + 2][j + 2] == Checker.EMPTY)) {						return true;					}				}								//down left				if (i + 2 <8  && j - 2 > -1) {					if ( (position[i + 1][j - 1] == Checker.WHITE || position[i + 1][j - 1] == Checker.WKing) &&						 (position[i + 2][j - 2] == Checker.EMPTY)) {						return true;					}				}				break;						case Checker.WHITE:				//up right				if (i - 2 >-1 && j + 2 < 8) {					if ( (position[i - 1][j + 1] == Checker.BLACK || position[i - 1][j + 1] == Checker.BKing) &&						 (position[i - 2][j + 2] == Checker.EMPTY)) {						return true;					}				}								//up left				if (i - 2 > -1 && j - 2 > -1) {					if ( (position[i - 1][j - 1] == Checker.BLACK || position[i - 1][j - 1] == Checker.BKing) &&						 (position[i - 2][j - 2] == Checker.EMPTY)) {						return true;					}				}				break;			case Checker.WKing:				if (i + 2 < 8) {					if (j + 2 < 8) {						if ( (position[i + 1][j + 1] == Checker.BLACK || position[i + 1][j + 1] == Checker.BKing) &&							 (position[i + 2][j + 2] == Checker.EMPTY)) {							return true;						}					}										if (j - 2 > -1) {						if ( (position[i + 1][j - 1] == Checker.BLACK || position[i + 1][j - 1] == Checker.BKing) &&							 (position[i + 2][j - 2] == Checker.EMPTY)) {							return true;
						}					}				}								if (i - 2 > -1) {					if (j + 2 < 8) {						if ( (position[i - 1][j + 1] == Checker.BLACK || position[i - 1][j + 1] == Checker.BKing) &&							 (position[i - 2][j + 2] == Checker.EMPTY)) {							return true;						}					}					if (j - 2 > -1) {						if ( (position[i - 1][j - 1] == Checker.BLACK || position[i - 1][j - 1] == Checker.BKing) &&							 (position[i - 2][j - 2] == Checker.EMPTY)) {
							return true;						}					}				}				break;						case Checker.BKing:				if (i + 2 < 8) {					if (j + 2 < 8) {						if ( (position[i + 1][j + 1] == Checker.WHITE || position[i + 1][j + 1] == Checker.WKing) &&							 (position[i + 2][j + 2] == Checker.EMPTY)) {							return true;						}					}					if (j - 2 > -1) {						if ( (position[i + 1][j - 1] == Checker.WHITE || position[i + 1][j - 1] == Checker.WKing) &&							 (position[i + 2][j - 2] == Checker.EMPTY)) {							return true;						}					}
				}								if (i - 2 > -1) {					if (j + 2 < 8) {						if ( (position[i - 1][j + 1] == Checker.WHITE || position[i - 1][j + 1] == Checker.WKing) &&							 (position[i - 2][j + 2] == Checker.EMPTY)) {							return true;						}					}					if (j - 2 > -1) {						if ( (position[i - 1][j - 1] == Checker.WHITE || position[i - 1][j - 1] == Checker.WKing) &&							 (position[i - 2][j - 2] == Checker.EMPTY)) {							return true;						}					}				}				break;		}				return false;	}
	// canWalk() returns true if the piece on (i,j) can make a	// legal non-capturing move	private static boolean canWalk(int[][] position, int i, int j) {		switch (position[i][j]) {			case Checker.BLACK:				if (isEmpty(position, i + 1, j + 1) || isEmpty(position, i + 1, j - 1))					return true;				break;	
			case Checker.WHITE:				if (isEmpty(position, i - 1, j + 1) || isEmpty(position, i - 1, j - 1))					return true;				break;						case Checker.WKing:			case Checker.BKing:				if (isEmpty(position, i + 1, j + 1) || isEmpty(position, i + 1, j - 1) || 					isEmpty(position, i - 1, j + 1) || isEmpty(position, i - 1, j - 1))					return true;		}				return false;	}
	private static boolean isEmpty(int[][] position, int i, int j) {		if (i > -1 && i < 8 && j > -1 && j < 8) {			if (position[i][j] == Checker.EMPTY)				return true;		}		return false;	}
	private static boolean noMovesLeft(int[][] position, int toMove) {		for (int i = 0; i < 8; i++) {			for (int j = 0; j < 8; j++) {				if ( (float) (i + j) / 2 != (i + j) / 2) {					if (toMove == Checker.WHITE &&						(position[i][j] == Checker.WHITE || position[i][j] == Checker.WKing)) {						if (canWalk(position, i, j))							return false;						else if (canCapture(position, i, j))							return false;
					}					else if (toMove == Checker.BLACK &&							 (position[i][j] == Checker.BLACK || position[i][j] == Checker.BKing)) {						if (canWalk(position, i, j)) 							return false;
						else if (canCapture(position, i, j))							return false;					}				}			}		}
		return true;
	}
	// IsMoveLegal checks if the move entered is legal.	// Returns ILLEGALMOVE or LEGALMOVE;	// have to check with canCapture(int[][],int,int) to see	// if there is another capture possible after the first capture	// Returns INCOMPLETEMOVE if a capture has taken place.	private static int IsMoveLegal(int[][] position, int start_i, int start_j, int end_i, int end_j, int turn) {		if (! (inRange(start_i, start_j) && inRange(end_i, end_j))) 			return ILLEGALMOVE;		if (position[end_i][end_j] != Checker.EMPTY) 			return ILLEGALMOVE;		if (incomplete&&((row_force!=start_i)||col_force!=start_j))			return ILLEGALMOVE;			int piece = position[start_i][start_j];		if (Math.abs(start_i - end_i) == 1) {
			// first see if any captures are possible			switch (piece) {				case Checker.WHITE:				case Checker.WKing:					for (int i = 0; i < 8; i++) {						for (int j = 0; j < 8; j++) {							if ( (position[i][j] == Checker.WHITE || position[i][j] == Checker.WKing) && 								 canCapture(position, i, j)) {								return ILLEGALMOVE;							}						}					}				break;
				case Checker.BLACK:				case Checker.BKing:					for (int i = 0; i < 8; i++) {						for (int j = 0; j < 8; j++) {							if ( (position[i][j] == Checker.BLACK || position[i][j] == Checker.BKing) &&								 canCapture(position, i, j)) {								return ILLEGALMOVE;							}						}					}				break;
			}						switch (piece) {				case Checker.WHITE:
					if ((end_i - start_i == -1)&&(end_j - start_j == -1||end_j - start_j == 1))						return LEGALMOVE;					break;				case Checker.BLACK:					if ((end_i - start_i == 1)&&(end_j - start_j == -1||end_j - start_j == 1))						return LEGALMOVE;					break;				case Checker.WKing:				case Checker.BKing:					if (Math.abs(end_j - start_j) == 1)						return LEGALMOVE;					break;			}						return ILLEGALMOVE;
		}		else if (Math.abs(start_i - end_i) == 2&&Math.abs(start_j - end_j) == 2) {			int cap_i = (start_i + end_i) / 2;			int cap_j = (start_j + end_j) / 2;			int cap_piece = position[cap_i][cap_j];						if (turn == Checker.WHITE||turn == Checker.WKing) {				if (! (cap_piece == Checker.BLACK || cap_piece == Checker.BKing)) 					return ILLEGALMOVE;			}			if (turn == Checker.BLACK||turn == Checker.BKing){				if (! (cap_piece == Checker.WHITE || cap_piece == Checker.WKing))
					return ILLEGALMOVE;			}			switch (piece) {				case Checker.WHITE:					if (end_i - start_i != -2)						return ILLEGALMOVE;					break;				case Checker.BLACK:					if (end_i - start_i != 2)						return ILLEGALMOVE;					break;				case Checker.WKing:				case Checker.BKing:					if (Math.abs(end_i - start_i) != 2)						return ILLEGALMOVE;			}						return INCOMPLETEMOVE;		}				return ILLEGALMOVE;
	}
	// checkers that i and j are between 0 and 7 inclusive	private static boolean inRange(int i, int j) {		return (i > -1 && i < 8 && j > -1 && j < 8);	}		private static int ApplyMove(int[][] position, int start_i, int start_j, int end_i, int end_j) {		int result = IsMoveLegal(position, start_i, start_j, end_i, end_j, position[start_i][start_j]);
				if (result != ILLEGALMOVE) {			if (Math.abs(end_i - start_i) == 1) {				position[end_i][end_j] = position[start_i][start_j];				position[start_i][start_j] = Checker.EMPTY;			}			else { // capture				position[ (start_i + end_i) / 2][ (start_j + end_j) / 2] = Checker.EMPTY;				position[end_i][end_j] = position[start_i][start_j];				position[start_i][start_j] = Checker.EMPTY;			}						if (result == INCOMPLETEMOVE) {				// if there are no further captures				if (! (canCapture(position, end_i, end_j))) {					result = LEGALMOVE;					incomplete=false;					row_force = -1;					col_force = -1;				}
				else {					//force next move					incomplete = true;					row_force = end_i;					col_force = end_j;				}			}
			// check for new king			if (position[end_i][end_j] == Checker.WHITE && end_i == 0)				position[end_i][end_j] = Checker.WKing;			else if (position[end_i][end_j] == Checker.BLACK && end_i == 7)				position[end_i][end_j] = Checker.BKing;		}		return result;	}
	public int [][] getCopyOfBoardArray(){		return (int [][])board.clone();	}	
}

