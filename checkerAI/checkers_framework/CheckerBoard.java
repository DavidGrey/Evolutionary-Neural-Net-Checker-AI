package checkers_framework;public class CheckerBoard {	/**	 * Logger for this class	 */	private int[][] board;
	public final static int LEGALMOVE = 1;	public final static int ILLEGALMOVE = 2;	public final static int INCOMPLETEMOVE = 3;	private  int row_force=-1;	private  int col_force=-1;	private  boolean incomplete = false;		public CheckerBoard() {		board = new int[8][8]; // row-major		initializeBoard();
	}	public CheckerBoard(CheckerBoard b) {		board = new int[8][8];				for (int row = 0; row < 8; ++row) {			for (int col = 0; col < 8; ++col) {				board[row][col] = b.board[row][col];			}		}	}		// Sets board to standard start of game configuration.
	private void initializeBoard() {		for (int row = 0; row < 8; ++row) {			for (int col = 0; col < 8; ++col) {				board[row][col] = Checker.EMPTY;			}		}//				board[7][0] = Checker.WHITE;		board[7][2] = Checker.WHITE;		board[7][4] = Checker.WHITE;		board[7][6] = Checker.WHITE;		board[6][1] = Checker.WHITE;		board[6][3] = Checker.WHITE;		board[6][5] = Checker.WHITE;		board[6][7] = Checker.WHITE;		board[5][0] = Checker.WHITE;		board[5][2] = Checker.WHITE;		board[5][4] = Checker.WHITE;		board[5][6] = Checker.WHITE;
		board[2][1] = Checker.BLACK;		board[2][3] = Checker.BLACK;		board[2][5] = Checker.BLACK;		board[2][7] = Checker.BLACK;		board[1][0] = Checker.BLACK;		board[1][2] = Checker.BLACK;		board[1][4] = Checker.BLACK;		board[1][6] = Checker.BLACK;		board[0][1] = Checker.BLACK;		board[0][3] = Checker.BLACK;		board[0][5] = Checker.BLACK;		board[0][7] = Checker.BLACK;	}

	public int getSquareContents(int row, int col){  		return board[row][col];	}
	public int getBlackScore(){
		int score = 0;		for (int row = 0; row < 8; ++row){			for (int col = 0; col < 8; ++col){				if (board[row][col] == Checker.BLACK||board[row][col] == Checker.BKing)					++score;			}		}		return score;	}
	public int getWhiteScore(){		int score = 0;		for (int row = 0; row < 8; ++row){			for (int col = 0; col < 8; ++col){				if (board[row][col] == Checker.WHITE||board[row][col] == Checker.WKing)					++score;			}		}		return score;	}
	public int move(Move m, int moveColor) {		return makeMove(m.currow, m.curcol, m.sucrow, m.succol, moveColor);	}
	// This method has all the logic for determining whether the
	// move passed in the parameters is legal.  If the last
	// parameter is true, it actually updates the board.	private int makeMove(int currow, int curcol, int sucrow, int succol, int moveColor) {		switch (moveColor){			case Checker.WHITE:				if (board[currow][curcol]!=Checker.WHITE&&board[currow][curcol]!=Checker.WKing) 					return ILLEGALMOVE; 				break;			case Checker.BLACK:				if (board[currow][curcol]!=Checker.BLACK&&board[currow][curcol]!=Checker.BKing) 					return ILLEGALMOVE;				break;		}
		return ApplyMove(board, currow, curcol, sucrow, succol);	}		public  boolean isValidMove(int [][] position, int currow, int curcol, int sucrow, int succol, int moveColor) {		switch (moveColor){			case Checker.WHITE:				if (position[currow][curcol]!=Checker.WHITE&&position[currow][curcol]!=Checker.WKing) 					return false;				break;			case Checker.BLACK:				if (position[currow][curcol]!=Checker.BLACK&&position[currow][curcol]!=Checker.BKing) 					return false; 				break;		}				int dummy=IsMoveLegal(position, currow, curcol, sucrow, succol, moveColor);		if (dummy==LEGALMOVE||dummy==INCOMPLETEMOVE) 			return true;		return false;	}	private static boolean canCapture(int[][] position, int i, int j) {
		switch (position[i][j]) {			case Checker.BLACK:				//down right				if (i + 2 < 8 && j + 2 < 8) {					if ( (position[i + 1][j + 1] == Checker.WHITE || position[i + 1][j + 1] == Checker.WKing) && 						 (position[i + 2][j + 2] == Checker.EMPTY)) {						return true;					}				}								//down left				if (i + 2 <8  && j - 2 > -1) {					if ( (position[i + 1][j - 1] == Checker.WHITE || position[i + 1][j - 1] == Checker.WKing) &&						 (position[i + 2][j - 2] == Checker.EMPTY)) {						return true;					}				}				break;						case Checker.WHITE:				//up right				if (i - 2 >-1 && j + 2 < 8) {					if ( (position[i - 1][j + 1] == Checker.BLACK || position[i - 1][j + 1] == Checker.BKing) &&						 (position[i - 2][j + 2] == Checker.EMPTY)) {						return true;					}				}								//up left				if (i - 2 > -1 && j - 2 > -1) {					if ( (position[i - 1][j - 1] == Checker.BLACK || position[i - 1][j - 1] == Checker.BKing) &&						 (position[i - 2][j - 2] == Checker.EMPTY)) {						return true;					}				}				break;			case Checker.WKing:				if (i + 2 < 8) {					if (j + 2 < 8) {						if ( (position[i + 1][j + 1] == Checker.BLACK || position[i + 1][j + 1] == Checker.BKing) &&							 (position[i + 2][j + 2] == Checker.EMPTY)) {							return true;						}					}										if (j - 2 > -1) {						if ( (position[i + 1][j - 1] == Checker.BLACK || position[i + 1][j - 1] == Checker.BKing) &&							 (position[i + 2][j - 2] == Checker.EMPTY)) {							return true;
						}					}				}								if (i - 2 > -1) {					if (j + 2 < 8) {						if ( (position[i - 1][j + 1] == Checker.BLACK || position[i - 1][j + 1] == Checker.BKing) &&							 (position[i - 2][j + 2] == Checker.EMPTY)) {							return true;						}					}					if (j - 2 > -1) {						if ( (position[i - 1][j - 1] == Checker.BLACK || position[i - 1][j - 1] == Checker.BKing) &&							 (position[i - 2][j - 2] == Checker.EMPTY)) {
							return true;						}					}				}				break;						case Checker.BKing:				if (i + 2 < 8) {					if (j + 2 < 8) {						if ( (position[i + 1][j + 1] == Checker.WHITE || position[i + 1][j + 1] == Checker.WKing) &&							 (position[i + 2][j + 2] == Checker.EMPTY)) {							return true;						}					}					if (j - 2 > -1) {						if ( (position[i + 1][j - 1] == Checker.WHITE || position[i + 1][j - 1] == Checker.WKing) &&							 (position[i + 2][j - 2] == Checker.EMPTY)) {							return true;						}					}
				}								if (i - 2 > -1) {					if (j + 2 < 8) {						if ( (position[i - 1][j + 1] == Checker.WHITE || position[i - 1][j + 1] == Checker.WKing) &&							 (position[i - 2][j + 2] == Checker.EMPTY)) {							return true;						}					}					if (j - 2 > -1) {						if ( (position[i - 1][j - 1] == Checker.WHITE || position[i - 1][j - 1] == Checker.WKing) &&							 (position[i - 2][j - 2] == Checker.EMPTY)) {							return true;						}					}				}				break;		}				return false;	}


	// IsMoveLegal checks if the move entered is legal.	// Returns ILLEGALMOVE or LEGALMOVE;	// have to check with canCapture(int[][],int,int) to see	// if there is another capture possible after the first capture	// Returns INCOMPLETEMOVE if a capture has taken place.	private  int IsMoveLegal(int[][] position, int start_i, int start_j, int end_i, int end_j, int turn) {		if (! (inRange(start_i, start_j) && inRange(end_i, end_j))) 			return ILLEGALMOVE;		if (position[end_i][end_j] != Checker.EMPTY) 			return ILLEGALMOVE;		if (incomplete&&((row_force!=start_i)||col_force!=start_j))			return ILLEGALMOVE;			int piece = position[start_i][start_j];		if (Math.abs(start_i - end_i) == 1) {
			// first see if any captures are possible			switch (piece) {				case Checker.WHITE:				case Checker.WKing:					for (int i = 0; i < 8; i++) {						for (int j = 0; j < 8; j++) {							if ( (position[i][j] == Checker.WHITE || position[i][j] == Checker.WKing) && 								 canCapture(position, i, j)) {								return ILLEGALMOVE;							}						}					}				break;
				case Checker.BLACK:				case Checker.BKing:					for (int i = 0; i < 8; i++) {						for (int j = 0; j < 8; j++) {							if ( (position[i][j] == Checker.BLACK || position[i][j] == Checker.BKing) &&								 canCapture(position, i, j)) {								return ILLEGALMOVE;							}						}					}				break;
			}						switch (piece) {				case Checker.WHITE:
					if ((end_i - start_i == -1)&&(end_j - start_j == -1||end_j - start_j == 1))						return LEGALMOVE;					break;				case Checker.BLACK:					if ((end_i - start_i == 1)&&(end_j - start_j == -1||end_j - start_j == 1))						return LEGALMOVE;					break;				case Checker.WKing:				case Checker.BKing:					if (Math.abs(end_j - start_j) == 1)						return LEGALMOVE;					break;			}						return ILLEGALMOVE;
		}		else if (Math.abs(start_i - end_i) == 2 && Math.abs(start_j - end_j) == 2) {			int cap_i = (start_i + end_i) / 2;			int cap_j = (start_j + end_j) / 2;			int cap_piece = position[cap_i][cap_j];						if (turn == Checker.WHITE||turn == Checker.WKing) {				if (! (cap_piece == Checker.BLACK || cap_piece == Checker.BKing)) 					return ILLEGALMOVE;			}			if (turn == Checker.BLACK||turn == Checker.BKing){				if (! (cap_piece == Checker.WHITE || cap_piece == Checker.WKing))
					return ILLEGALMOVE;			}			switch (piece) {				case Checker.WHITE:					if (end_i - start_i != -2)						return ILLEGALMOVE;					break;				case Checker.BLACK:					if (end_i - start_i != 2)						return ILLEGALMOVE;					break;				case Checker.WKing:				case Checker.BKing:					if (Math.abs(end_i - start_i) != 2)						return ILLEGALMOVE;			}						return INCOMPLETEMOVE;		}				return ILLEGALMOVE;
	}
	// checkers that i and j are between 0 and 7 inclusive	private static boolean inRange(int i, int j) {		return (i > -1 && i < 8 && j > -1 && j < 8);	}		private  int ApplyMove(int[][] position, int start_i, int start_j, int end_i, int end_j) {		int result = IsMoveLegal(position, start_i, start_j, end_i, end_j, position[start_i][start_j]);
				if (result != ILLEGALMOVE) {			if (Math.abs(end_i - start_i) == 1) {				position[end_i][end_j] = position[start_i][start_j];				position[start_i][start_j] = Checker.EMPTY;			}			else { // capture				position[ (start_i + end_i) / 2][ (start_j + end_j) / 2] = Checker.EMPTY;				position[end_i][end_j] = position[start_i][start_j];				position[start_i][start_j] = Checker.EMPTY;			}						if (result == INCOMPLETEMOVE) {				// if there are no further captures				if (! (canCapture(position, end_i, end_j))) {					result = LEGALMOVE;					incomplete=false;					row_force = -1;					col_force = -1;				}
				else {					//force next move					incomplete = true;					row_force = end_i;					col_force = end_j;				}			}
			// check for new king			if (position[end_i][end_j] == Checker.WHITE && end_i == 0)				position[end_i][end_j] = Checker.WKing;			else if (position[end_i][end_j] == Checker.BLACK && end_i == 7)				position[end_i][end_j] = Checker.BKing;		}		return result;	}
	public int [][] getCopyOfBoardArray(){		int[][] n = new int[8][8];		for(int i = 0; i < 8; i++){			for(int j = 0; j<8; j++){				n[i][j] = board[i][j];			}		}		return n;	}	
}

